# -*- python -*-
# ex: set syntax=python:

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}
c['protocols'] = {'pb': {'port': 9989}}




####### BUILDSLAVES
from buildbot.buildslave import BuildSlave

ubuntu_names = []
for version in ["14.04", "12.04"]:
    for arch in ["x64", "x86"]:
        ubuntu_names += ["ubuntu%s-%s"%(version, arch)]

osx_names = ["osx10.7", "osx10.8", "osx10.9"]
arch_names = ["arch14.08-x64"]
centos_names = ["centos7.0-x64"]

c['slaves'] = []
for name in ubuntu_names + osx_names + arch_names + centos_names:
    arch = 'amd64'
    if name[-3:] == 'x86':
        arch = 'i386'
    c['slaves'] += [BuildSlave(name, 'julialang42', properties={'arch':arch, 'release':name})]




####### CHANGESOURCES
from buildbot.changes.pb import PBChangeSource
c['change_source'] = PBChangeSource(user='github', passwd='github.julialang42')




####### SCHEDULERS
from buildbot.schedulers.basic import AnyBranchScheduler, Dependent
from buildbot.schedulers.triggerable import Triggerable
from buildbot.schedulers.forcesched import *
from buildbot.changes import filter
c['schedulers'] = []

# Add a scheduler for julia continuous deployment
julia_builders = ["package_" + z for z in ubuntu_names + [osx_names[-1]]]
c['schedulers'].append(AnyBranchScheduler( name="julia build", treeStableTimer=None, builderNames=julia_builders))

# Add a scheduler for building bottles
bottle_builders = ["bottle_" + z for z in osx_names]
bottle_scheduler = ForceScheduler(
    name="bottle build",
    builderNames=bottle_builders,
    reason=FixedParameter(name="reason", default=""),
    branch=FixedParameter(name="branch", default=""),
    revision=FixedParameter(name="revision", default=""),
    repository=FixedParameter(name="repository", default=""),
    project=FixedParameter(name="project", default="Bottling"),
    properties=[
        StringParameter(name="formula", label="Formula", size=30, default="staticfloat/juliadeps/")
    ]
)
c['schedulers'].append(bottle_scheduler)

c['schedulers'].append(Triggerable( name="bottle upload", builderNames=["bottle_host"] ))


####### BUILD FACTORIES
from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.trigger import Trigger
from buildbot.steps.master import MasterShellCommand
from buildbot.process.properties import Property, Interpolate
from buildbot.steps.package.deb.pbuilder import DebPbuilder
from buildbot.steps.transfer import FileUpload, FileDownload


# Steps to build a Mac .dmg Julia package
osx_julia_package_factory = BuildFactory()
osx_julia_package_factory.useProgress = True
BUILD_OPTS=["LLVM_CONFIG=llvm-config-3.3", "LLVM_LLC=llc-3.3", "VERBOSE=1", "USE_BLAS64=0", "SUITESPARSE_INC='-I /usr/local/include'",
            "LIBBLAS=-lopenblas", "LIBBLASNAME=libopenblas", "LIBLAPACK=-lopenblas", "LIBLAPACKNAME=libopenblas"]
for lib in ["LLVM","ZLIB","SUITESPARSE","ARPACK","BLAS","FFTW","LAPACK","GMP","MPFR","PCRE","LIBUNWIND"]:
    BUILD_OPTS += ["USE_SYSTEM_%s=1"%(lib)]
osx_julia_package_factory.addSteps([
    # Clone julia
    Git(name="Julia checkout", repourl=Property('repository', default='git://github.com/JuliaLang/julia.git'), mode='incremental', method='clean', submodules=True, clobberOnFailure=True, progress=True),

    # Install brew dependencies and force-link them so that keg_only deps don't require funky environment variables
    ShellCommand(command=["brew", "install", "--only-dependencies", "julia"]),
    ShellCommand(command=["brew", "link", "--force", "llvm33-julia", "arpack-julia", "suite-sparse-julia", "openblas-julia"]),

    # Repackage suite-sparse
    ShellCommand(command=["make", "-C", "contrib", "-f", "repackage_system_suitesparse4.make"] + BUILD_OPTS, haltOnFailure=True),

    # Make!
    ShellCommand(command=["make"] + BUILD_OPTS, haltOnFailure=True),

    # Do the tests
    ShellCommand(command=["make", "testall"] + BUILD_OPTS, haltOnFailure=True),

    # Actually package the darn thing
    ShellCommand(command=["make", "-C", "contrib/mac/app"] + BUILD_OPTS),

    # Upload the package to the host!
    SetPropertyFromCommand(name="Get dmg filename", command=["/bin/bash", "-c", "cd contrib/mac/app && echo *.dmg"], property="filename"),
    MasterShellCommand(name="Make julia_package", command=["mkdir", "-p", "/tmp/julia_package"]),
    FileUpload(slavesrc=Interpolate("contrib/mac/app/%(prop:filename)s"), masterdest=Interpolate("/tmp/julia_package/%(prop:filename)s")),

    # Now upload to AWS!
    MasterShellCommand(name="Upload to AWS", command=["~/bin/aws", "put", "x-amz-acl: public-read", "julianightlies", Interpolate("/tmp/julia_package/%(prop:filename)s.dmg")])
])


# Steps to build a Homebrew Bottle
osx_bottle_factory = BuildFactory()
osx_bottle_factory.useProgress = True
osx_bottle_factory.addSteps([
    # Clean everything out that's in the directory!
    ShellCommand(name="precleanup", command=["/bin/bash", "-c", "rm -f *.{sh,gz}"]),
    # Copy our build_bottle.sh script over to the slave:
    FileDownload(mastersrc="../commands/build_bottle.sh", slavedest="build_bottle.sh"),
    
    # Next, invoke build_bottle.sh!
    ShellCommand(command=["/bin/bash", "build_bottle.sh", Property('formula')], haltOnFailure=True),

    # Grab the output and transfer it back!
    SetPropertyFromCommand(name="Get bottle filename", command=["/bin/bash", "-c", "echo *.tar.gz"], property="filename"),
    MasterShellCommand(name="Make bottle_cache", command=["mkdir", "-p", "/tmp/bottle_cache"]),
    FileUpload(slavesrc=Interpolate("%(prop:filename)s"), masterdest=Interpolate("/tmp/bottle_cache/%(prop:filename)s")),

    # Trigger our host bottle upload step!
    Trigger(schedulerNames=['bottle upload'], set_properties={'formula': Property('formula')})
])


# Steps to upload a Homebrew bottle from the master
host_bottle_upload = BuildFactory()
host_bottle_upload.useProgress = True
host_bottle_upload.addSteps([
    # Run upload_bottle_archive.sh
    MasterShellCommand(name="Upload Bottle", command=["/bin/bash", "../commands/upload_bottle.sh", Interpolate("%(prop:formula)s")])
])



# Steps to build an Ubuntu .deb Julia Package
ubuntu_package_julia_factory = BuildFactory()
ubuntu_package_julia_factory.useProgress = True
ubuntu_package_julia_factory.addSteps([
    # Clone julia
    Git(name="Julia checkout", repourl=Property('repository', default='git://github.com/JuliaLang/julia.git'), mode='incremental', method='clean', submodules=True, clobberOnFailure=True, progress=True),

    # Perform pre-tarball steps
    ShellCommand(name="version_git.jl", command=["make", "-C", "base", "version_git.jl.phony"]),
    ShellCommand(name="Get dependencies", command=["make", "-C", "deps", "get-dsfmt"]),

    # Save the combined version string and release
    SetPropertyFromCommand(name="Compute debversion", command=["/bin/bash", "-c", "echo $(cat ./VERSION | cut -f1 -d'-')~pre+$(git rev-list HEAD ^$(git describe --tags --abbrev=0) | wc -l | sed -e 's/[^[:digit:]]//g')"], property="debversion"),

    # Make the source tarball
    ShellCommand(name="Source Tarball", command=["/bin/bash", "-c", Interpolate("tar --exclude .git -czf ../julia_%(prop:debversion)s.orig.tar.gz .")]),

    # Get the debian/ directory
    ShellCommand(name="Get debian/", command=["/bin/bash", "-c", "rm -rf debian; wget https://github.com/staticfloat/julia-debian/archive/master.tar.gz -O- | tar -zx --exclude README.md --strip-components=1"]),
    
    # Bump the version
    ShellCommand(name="Bump debian version", command=["/bin/bash", "-c", Interpolate("EMAIL='Elliot Saba <staticfloat@gmail.com>' dch -v %(prop:debversion)s 'nightly git build'")]),
    # Build the .deb!
    ShellCommand(name="debuild", command=["debuild"]),
    
    # Upload the result!
    MasterShellCommand(name="Make julia_package", command=["mkdir", "-p", "/tmp/julia_package"]),
    FileUpload(slavesrc=Interpolate("../julia_%(prop:debversion)s_%(prop:arch)s.deb"), masterdest=Interpolate("/tmp/julia_package/julia_%(prop:debversion)s~%(prop:release)s_%(prop:arch)s.deb")),

    # Since this stuff is getting thrown into the parent directory, we need to clean up after ourselves!
    ShellCommand(name="cleanup", command=["/bin/bash", "-c", "rm -f ../*.{gz,build,dsc,deb,changes}"])
])



####### BUILDERS
from buildbot.config import BuilderConfig
c['builders'] = []

# Add all the ubuntu julia packagers
for name in ubuntu_names:
    c['builders'].append(BuilderConfig(
        name="package_%s"%(name),
        slavenames=[name],
        category="Packaging",
        factory=ubuntu_package_julia_factory
    ))

# Add my osx julia packager (we only need one right now!)
c['builders'].append(BuilderConfig(
    name="package_%s"%(osx_names[-1]),
    slavenames=["osx10.9"],
    category="Packaging",
    factory=osx_julia_package_factory
))

# Add bottlers
for name in osx_names:
    c['builders'].append(BuilderConfig(
        name="bottle_%s"%(name),
        slavenames=[name],
        category="Bottling",
        factory=osx_bottle_factory
    ))
c['builders'].append(BuilderConfig(
    name="bottle_host",
    slavenames=ubuntu_names+osx_names,
    category="Bottling",
    factory=host_bottle_upload
))




####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth

try:
    from buildbot_secret import *
except:
    IOError('Could not load buildbot_secret.py! Ensure you have a buildbot_secret.py in this directory, and that it defines an ADMIN_USER and ADMIN_PASSWD variables!!')


authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth([(ADMIN_USER,ADMIN_PASSWD)]),
    gracefulShutdown = False,
    forceBuild = 'auth', # use this to test your slave once it is set up
    forceAllBuilds = 'auth',
    pingBuilder = False,
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)
# Also setup Github hook here
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Julia"
c['titleURL'] = "http://julialang.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://buildbot.e.ip.saba.us:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
